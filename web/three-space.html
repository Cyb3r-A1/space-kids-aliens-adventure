<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Explorer Adventure - Three.js 3D Space</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #000;
            color: #cfe6ff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #app { position: fixed; inset: 0; }
        .hud {
            position: fixed;
            top: 16px;
            left: 16px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #4a9eff;
            border-radius: 10px;
            padding: 12px 14px;
            z-index: 10;
        }
        .hud h3 { margin: 0 0 6px 0; color: #ffd700; }
        .hud .key { color: #ffd700; font-weight: bold; }
        .hud .hint { color: #9fd0ff; font-size: 12px; opacity: 0.9; }
        .toggle { position: fixed; right: 16px; bottom: 16px; z-index: 11; }
        .btn {
            display: inline-block; padding: 10px 14px; border-radius: 20px; border: 1px solid #4a9eff;
            background: rgba(0,0,0,0.6); color: #4a9eff; text-decoration: none; font-weight: bold;
        }
        .is-hidden { opacity: 0; pointer-events: none; transition: opacity .35s ease; }
    </style>
</head>
<body>
    <div class="hud" id="hud">
        <h3>üöÄ 3D Space Flight</h3>
        <div><span class="key">Click</span> to lock mouse ‚Ä¢ <span class="key">ESC</span> to release</div>
        <div><span class="key">W/S</span> thrust ‚Ä¢ <span class="key">A/D</span> strafe ‚Ä¢ <span class="key">Q/E</span> roll</div>
        <div><span class="key">Shift</span> boost ‚Ä¢ <span class="key">H</span> toggle help</div>
        <div class="hint">Planets: Earth (clouds), Mars, Jupiter ‚Ä¢ Sunlight with bloom</div>
    </div>
    <div class="toggle"><a href="#" id="helpBtn" class="btn">‚ùî Help (H)</a></div>
    <div id="app"></div>
    <div id="hudOverlay" style="position:fixed;inset:0;pointer-events:none;z-index:9;">
        <div id="reticle" style="position:absolute;left:50%;top:50%;width:20px;height:20px;transform:translate(-50%,-50%);">
            <div style="position:absolute;left:9px;top:0;width:2px;height:20px;background:#4a9eff;box-shadow:0 0 6px rgba(74,158,255,.9);"></div>
            <div style="position:absolute;left:0;top:9px;width:20px;height:2px;background:#4a9eff;box-shadow:0 0 6px rgba(74,158,255,.9);"></div>
        </div>
        <div id="speedHud" style="position:absolute;right:16px;bottom:16px;background:rgba(0,0,0,.6);border:1px solid #4a9eff;border-radius:10px;padding:8px 12px;color:#9fd0ff;font:12px/1.4 Arial,sans-serif;">
            <div>Speed: <span id="speedValue">0</span></div>
            <div>Boost: <span id="boostValue">off</span></div>
        </div>
        <div id="missionHud" style="position:absolute;right:16px;top:16px;background:rgba(0,0,0,.7);border:1px solid #ffd700;border-radius:10px;padding:10px 12px;color:#cfe6ff;font:12px/1.4 Arial,sans-serif;display:none;max-width:320px;">
            <div style="color:#ffd700;font-weight:bold;margin-bottom:4px;">üéØ Mission</div>
            <div id="missionText"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { EffectComposer } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js?deps=three@0.160.0';
        import { RenderPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/RenderPass.js?deps=three@0.160.0';
        import { UnrealBloomPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js?deps=three@0.160.0';

        // Error display helper
        const errEl = document.createElement('div');
        errEl.style.cssText = 'position:fixed;top:0;left:0;right:0;background:rgba(0,0,0,.8);color:#ff8080;padding:8px 12px;font:12px/1.4 monospace;z-index:9999;display:none;';
        document.body.appendChild(errEl);
        window.addEventListener('error', (e) => { errEl.textContent = 'Error: ' + (e.message || 'Unknown'); errEl.style.display = 'block'; });

        // Renderer
        const canvasParent = document.getElementById('app');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = false;
        renderer.setClearColor(0x000010, 1);
        canvasParent.appendChild(renderer.domElement);

        // Scene & Camera
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 50000);
        camera.position.set(0, 10, 60);

        // Postprocessing with safe fallback
        let composer = null;
        let useComposer = false;
        try {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.9, 0.2);
            composer.addPass(bloomPass);
            useComposer = true;
        } catch (e) {
            console.warn('Postprocessing unavailable, falling back to direct render:', e);
            errEl.textContent = 'Note: running without postprocessing (fallback).';
            errEl.style.display = 'block';
        }

        // Starfield (Points)
        function createStarfield(count = 4000, radius = 4000) {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const r = radius * (0.4 + Math.random() * 0.6);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                positions[i * 3 + 0] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0x99bbff, size: 1.2, sizeAttenuation: true });
            const points = new THREE.Points(geom, mat);
            points.renderOrder = -1000;
            scene.add(points);
        }
        createStarfield();

        // Lighting (Sun)
        const sun = new THREE.DirectionalLight(0xffffff, 2.2);
        sun.position.set(300, 200, 100);
        scene.add(sun);
        const ambient = new THREE.AmbientLight(0x223355, 0.75);
        scene.add(ambient);

        // Textures
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin('anonymous');
        const PLANET_URL = 'https://threejs.org/examples/textures/planets/';
        function asyncLoad(url, onLoad) {
            try {
                loader.load(url, (t) => {
                    if (t) { t.colorSpace = THREE.SRGBColorSpace; }
                    onLoad && onLoad(t);
                }, undefined, () => {
                    onLoad && onLoad(null);
                });
            } catch (e) { onLoad && onLoad(null); }
        }

        // Planets
        function makeEarth() {
            const geo = new THREE.SphereGeometry(10, 64, 64);
            const mat = new THREE.MeshPhysicalMaterial({
                roughness: 0.9,
                metalness: 0.0,
                clearcoat: 0.2,
                envMapIntensity: 0.4
            });
            const earth = new THREE.Mesh(geo, mat);
            earth.position.set(-80, 0, -40);

            // Base color fallback so it's not black if textures fail
            mat.color = new THREE.Color(0x3b6dbb);
            // Load textures asynchronously; if they fail, we keep the fallback
            asyncLoad(PLANET_URL + 'earth_atmos_2048.jpg', (t) => { if (t) { mat.map = t; mat.needsUpdate = true; } });
            asyncLoad(PLANET_URL + 'earth_normal_2048.jpg', (t) => { if (t) { mat.normalMap = t; mat.needsUpdate = true; } });

            // Specular overlay
            const spec = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.18 });
            const earthSpecMesh = new THREE.Mesh(geo.clone(), spec);
            asyncLoad(PLANET_URL + 'earth_specular_2048.jpg', (t) => { if (t) { spec.map = t; spec.needsUpdate = true; } });
            earth.add(earthSpecMesh);

            // Clouds
            const cloudsGeo = new THREE.SphereGeometry(10.15, 64, 64);
            const cloudsMat = new THREE.MeshLambertMaterial({ transparent: true, opacity: 0.5, depthWrite: false });
            const clouds = new THREE.Mesh(cloudsGeo, cloudsMat);
            asyncLoad(PLANET_URL + 'earth_clouds_1024.png', (t) => { if (t) { cloudsMat.map = t; cloudsMat.needsUpdate = true; } });
            earth.add(clouds);

            scene.add(earth);
            return { earth, clouds };
        }

        function makeMars() {
            const geo = new THREE.SphereGeometry(6, 64, 64);
            const mat = new THREE.MeshStandardMaterial({ color: 0xbd5c3a, roughness: 1.0, metalness: 0.0 });
            asyncLoad(PLANET_URL + 'mars_1k_color.jpg', (t) => { if (t) { mat.map = t; mat.needsUpdate = true; } });
            const mars = new THREE.Mesh(geo, mat);
            mars.position.set(70, -8, -20);
            scene.add(mars);
            return mars;
        }

        function makeJupiter() {
            const geo = new THREE.SphereGeometry(18, 64, 64);
            const mat = new THREE.MeshStandardMaterial({ color: 0xd6a56a, roughness: 1.0, metalness: 0.0 });
            asyncLoad(PLANET_URL + 'jupiter2_1024.jpg', (t) => { if (t) { mat.map = t; mat.needsUpdate = true; } });
            const jupiter = new THREE.Mesh(geo, mat);
            jupiter.position.set(140, 20, -120);
            scene.add(jupiter);
            return jupiter;
        }

        const { earth, clouds } = makeEarth();
        const mars = makeMars();
        const jupiter = makeJupiter();

        // Sanity cube near the ship to prove rendering even without textures
        const sanity = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({ color: 0x4a9eff, emissive: 0x0b2a66, roughness: 0.4 }));
        sanity.position.set(8, 2.5, 0);
        scene.add(sanity);

        // Simple Spaceship (procedural) with emissive thrusters
        function makeShip() {
            const group = new THREE.Group();
            const hullMat = new THREE.MeshPhysicalMaterial({ color: 0x9aa3ad, metalness: 0.85, roughness: 0.22, clearcoat: 0.7, clearcoatRoughness: 0.18 });
            const glassMat = new THREE.MeshPhysicalMaterial({ color: 0x223344, metalness: 0.0, roughness: 0.05, transmission: 0.7, thickness: 0.2, transparent: true });
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x66ccff });

            // Fuselage
            const fuselage = new THREE.Mesh(new THREE.CapsuleGeometry(4, 14, 8, 16), hullMat);
            fuselage.rotation.z = Math.PI / 2;
            group.add(fuselage);

            // Cockpit canopy
            const canopy = new THREE.Mesh(new THREE.SphereGeometry(3, 24, 24), glassMat);
            canopy.scale.set(1.2, 0.7, 0.9);
            canopy.position.set(0, 1.5, 0);
            group.add(canopy);

            // Wings
            const wingGeo = new THREE.BoxGeometry(12, 0.3, 3.6);
            const leftWing = new THREE.Mesh(wingGeo, hullMat);
            leftWing.position.set(0, -1.2, -3.2);
            const rightWing = leftWing.clone();
            rightWing.position.z = 3.2;
            group.add(leftWing, rightWing);

            // Thrusters
            const thrusterGeo = new THREE.CylinderGeometry(0.9, 1.2, 2.5, 16);
            const thruster1 = new THREE.Mesh(thrusterGeo, hullMat);
            thruster1.rotation.z = Math.PI / 2;
            thruster1.position.set(-9, -0.6, -1.8);
            const thruster2 = thruster1.clone(); thruster2.position.z = 1.8;
            group.add(thruster1, thruster2);

            const flameGeo = new THREE.ConeGeometry(0.9, 3.2, 16);
            const flame1 = new THREE.Mesh(flameGeo, glowMat);
            flame1.rotation.z = -Math.PI / 2;
            flame1.position.set(-10.4, -0.6, -1.8);
            const flame2 = flame1.clone(); flame2.position.z = 1.8;
            group.add(flame1, flame2);

            // Nacelles and gun pods
            const nacelleGeo = new THREE.CylinderGeometry(0.4, 0.6, 3.5, 12);
            const nacelleL = new THREE.Mesh(nacelleGeo, hullMat);
            nacelleL.rotation.z = Math.PI / 2;
            nacelleL.position.set(2.5, -1.0, -3.8);
            const nacelleR = nacelleL.clone(); nacelleR.position.z = 3.8;
            group.add(nacelleL, nacelleR);

            const gunGeo = new THREE.CylinderGeometry(0.18, 0.18, 2.2, 12);
            const gunL = new THREE.Mesh(gunGeo, new THREE.MeshStandardMaterial({ color: 0x88909a, metalness: 0.9, roughness: 0.2 }));
            gunL.rotation.z = Math.PI / 2;
            gunL.position.set(6.5, -1.0, -2.6);
            const gunR = gunL.clone(); gunR.position.z = 2.6;
            group.add(gunL, gunR);

            group.position.set(0, 0, 0);
            scene.add(group);
            return { group, flames: [flame1, flame2], guns: [gunL, gunR] };
        }

        const ship = makeShip();

        // Camera rig follows ship
        const rig = new THREE.Group();
        ship.group.add(rig);
        camera.position.set(-18, 6, 0);
        rig.add(camera);

        // Controls (Pointer lock style flight)
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false, mouseDown: false, arrowUp: false, arrowDown: false, arrowLeft: false, arrowRight: false };
        window.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') toggleHUD();
            if (e.key === 'w' || e.key === 'W') keys.w = true;
            if (e.key === 's' || e.key === 'S') keys.s = true;
            if (e.key === 'a' || e.key === 'A') keys.a = true;
            if (e.key === 'd' || e.key === 'D') keys.d = true;
            if (e.key === 'q' || e.key === 'Q') keys.q = true;
            if (e.key === 'e' || e.key === 'E') keys.e = true;
            if (e.key === 'Shift') keys.shift = true;
            if (e.key === 'ArrowUp') keys.arrowUp = true;
            if (e.key === 'ArrowDown') keys.arrowDown = true;
            if (e.key === 'ArrowLeft') keys.arrowLeft = true;
            if (e.key === 'ArrowRight') keys.arrowRight = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = false;
            if (e.key === 's' || e.key === 'S') keys.s = false;
            if (e.key === 'a' || e.key === 'A') keys.a = false;
            if (e.key === 'd' || e.key === 'D') keys.d = false;
            if (e.key === 'q' || e.key === 'Q') keys.q = false;
            if (e.key === 'e' || e.key === 'E') keys.e = false;
            if (e.key === 'Shift') keys.shift = false;
            if (e.key === 'ArrowUp') keys.arrowUp = false;
            if (e.key === 'ArrowDown') keys.arrowDown = false;
            if (e.key === 'ArrowLeft') keys.arrowLeft = false;
            if (e.key === 'ArrowRight') keys.arrowRight = false;
        });

        let pointerLocked = false;
        renderer.domElement.addEventListener('click', () => {
            if (!pointerLocked) {
                renderer.domElement.requestPointerLock();
            }
            keys.mouseDown = true;
        });
        window.addEventListener('mouseup', () => { keys.mouseDown = false; });
        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === renderer.domElement;
        });
        const mouse = { dx: 0, dy: 0 };
        document.addEventListener('mousemove', (e) => {
            if (!pointerLocked) return;
            mouse.dx += e.movementX || 0;
            mouse.dy += e.movementY || 0;
        });

        // WebAudio - initialized on first user gesture
        let audioCtx = null;
        let engineOsc = null;
        let engineGain = null;
        function initAudio() {
            if (audioCtx) return;
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            audioCtx = new Ctx();
            engineOsc = audioCtx.createOscillator();
            engineOsc.type = 'sawtooth';
            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0.0;
            engineOsc.connect(engineGain).connect(audioCtx.destination);
            engineOsc.start();
        }
        function playLaserSound() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            const gain = audioCtx.createGain();
            gain.gain.value = 0.2;
            osc.connect(gain).connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            osc.frequency.setValueAtTime(1200, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.08);
            gain.gain.setValueAtTime(0.22, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            osc.start(now);
            osc.stop(now + 0.12);
        }

        // Simulation params
        const thrustBase = 12.0;
        const boostMultiplier = 2.4;
        const strafeSpeed = 9.0;
        const rollSpeed = 1.6;
        const mouseSensitivity = 0.0024;
        let velocity = new THREE.Vector3();
        const projectiles = [];
        let fireCooldown = 0;
        const projectileSpeed = 220;
        const projectileLifetime = 2.2;

        // Engine trails (simple particle sprites)
        const trailParticles = [];
        const trailPool = [];
        const MAX_TRAILS = 160;
        function getTrailParticle() {
            let p = trailPool.pop();
            if (!p) {
                const geo = new THREE.SphereGeometry(0.18, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.85 });
                const mesh = new THREE.Mesh(geo, mat);
                p = { mesh, vel: new THREE.Vector3(), life: 0, maxLife: 0.6 };
            }
            p.life = 0;
            p.maxLife = 0.6;
            p.mesh.material.opacity = 0.85;
            return p;
        }
        function spawnTrailAt(pos, dir, speed) {
            if (trailParticles.length >= MAX_TRAILS) return;
            const p = getTrailParticle();
            p.mesh.position.copy(pos);
            const spread = new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6);
            p.vel.copy(dir).multiplyScalar(-8 - speed * 0.06).add(spread);
            scene.add(p.mesh);
            trailParticles.push(p);
        }
        function updateTrails(dt) {
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                const p = trailParticles[i];
                p.life += dt;
                p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                const t = Math.min(p.life / p.maxLife, 1);
                const op = 0.85 * (1 - t);
                p.mesh.material.opacity = op;
                p.mesh.scale.setScalar(1 - 0.6 * t);
                if (p.life >= p.maxLife) {
                    scene.remove(p.mesh);
                    trailParticles.splice(i, 1);
                    trailPool.push(p);
                }
            }
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) composer.setSize(window.innerWidth, window.innerHeight);
        });

        // HUD
        const hud = document.getElementById('hud');
        const helpBtn = document.getElementById('helpBtn');
        const speedValue = document.getElementById('speedValue');
        const boostValue = document.getElementById('boostValue');
        const missionHud = document.getElementById('missionHud');
        const missionText = document.getElementById('missionText');
        function toggleHUD() {
            hud.classList.toggle('is-hidden');
        }
        helpBtn.addEventListener('click', (e) => { e.preventDefault(); toggleHUD(); });

        // Asteroid field
        function createAsteroids(count = 120) {
            const asteroids = [];
            const geom = new THREE.IcosahedronGeometry(1.5, 1);
            for (let i = 0; i < count; i++) {
                const scale = 2 + Math.random() * 6;
                const mesh = new THREE.Mesh(geom.clone(), new THREE.MeshStandardMaterial({ color: 0x777777, roughness: 1.0, metalness: 0.0 }));
                mesh.scale.set(scale, scale * (0.7 + Math.random()*0.6), scale);
                mesh.position.set((Math.random()-0.5)*1200, (Math.random()-0.5)*800, (Math.random()-0.5)*1200);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                mesh.userData.rot = new THREE.Vector3(Math.random()*0.6, Math.random()*0.6, Math.random()*0.6);
                scene.add(mesh);
                asteroids.push(mesh);
            }
            return asteroids;
        }
        const asteroids = createAsteroids();

        // Explosions on impact
        const explosions = [];
        function spawnExplosion(position) {
            const parts = [];
            const count = 26;
            for (let i = 0; i < count; i++) {
                const geo = new THREE.SphereGeometry(0.25 + Math.random()*0.2, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffbb55, transparent: true, opacity: 1.0 });
                const m = new THREE.Mesh(geo, mat);
                m.position.copy(position);
                const dir = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize();
                const speed = 18 + Math.random()*22;
                parts.push({ mesh: m, vel: dir.multiplyScalar(speed) });
                scene.add(m);
            }
            const light = new THREE.PointLight(0xffaa66, 2, 80);
            light.position.copy(position);
            scene.add(light);
            explosions.push({ parts, light, life: 0, maxLife: 0.7 });
        }
        function updateExplosions(dt) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const e = explosions[i];
                e.life += dt;
                const t = e.life / e.maxLife;
                const fade = Math.max(1 - t, 0);
                e.light.intensity = 2 * fade;
                for (let j = 0; j < e.parts.length; j++) {
                    const pr = e.parts[j];
                    pr.mesh.position.add(pr.vel.clone().multiplyScalar(dt));
                    pr.mesh.material.opacity = fade;
                    pr.mesh.scale.setScalar(0.8 + t * 0.4);
                }
                if (e.life >= e.maxLife) {
                    for (let j = 0; j < e.parts.length; j++) {
                        scene.remove(e.parts[j].mesh);
                    }
                    scene.remove(e.light);
                    explosions.splice(i, 1);
                }
            }
        }

        // Mission integration
        let mission = null;
        let missionBeacon = null;
        async function loadMission() {
            try {
                const res = await fetch('/api/mission');
                const m = await res.json();
                mission = m;
                missionHud.style.display = 'block';
                missionText.textContent = `${m.planet} (${m.biome}) ‚Ä¢ ${m.objective} ‚Ä¢ ${m.difficulty} ‚Ä¢ ${m.reward} ‚Ä¢ ${m.timeLimit}`;
                // Place a beacon
                if (missionBeacon) scene.remove(missionBeacon);
                const geo = new THREE.ConeGeometry(4, 14, 12);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0x553300, emissiveIntensity: 0.8 });
                missionBeacon = new THREE.Mesh(geo, mat);
                missionBeacon.position.set(600, 60, -300);
                missionBeacon.rotation.x = Math.PI;
                scene.add(missionBeacon);
            } catch (e) {
                missionHud.style.display = 'block';
                missionText.textContent = 'Mission system offline (using local flight only)';
            }
        }
        loadMission();

        function fireProjectiles(dt) {
            fireCooldown -= dt;
            const wantFire = keys.mouseDown;
            if (wantFire && fireCooldown <= 0) {
                fireCooldown = 0.12; // 8+ shots/sec
                ship.guns.forEach((gun) => {
                    const proj = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 12), new THREE.MeshBasicMaterial({ color: 0x66ccff }));
                    proj.position.copy(gun.getWorldPosition(new THREE.Vector3()));
                    const dir = new THREE.Vector3(1,0,0).applyQuaternion(ship.group.quaternion).normalize();
                    proj.userData.vel = dir.multiplyScalar(projectileSpeed);
                    proj.userData.time = 0;
                    scene.add(proj);
                    projectiles.push(proj);
                });
                playLaserSound();
            }
            // Update and cull
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.userData.time += dt;
                p.position.add(p.userData.vel.clone().multiplyScalar(dt));
                if (p.userData.time > projectileLifetime) {
                    scene.remove(p);
                    projectiles.splice(i, 1);
                }
            }
        }

        function checkProjectileCollisions() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const a = asteroids[j];
                    const dist = p.position.distanceTo(a.position);
                    const approxRadius = 1.5 * Math.max(a.scale.x, a.scale.y, a.scale.z);
                    if (dist < approxRadius + 0.5) {
                        // Hit
                        spawnExplosion(a.position.clone());
                        scene.remove(a);
                        asteroids.splice(j, 1);
                        scene.remove(p);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            const dt = Math.min(clock.getDelta(), 0.05);

            // Mouse look
            if (pointerLocked) {
                const yaw = -mouse.dx * mouseSensitivity;
                const pitch = -mouse.dy * mouseSensitivity;
                ship.group.rotation.y += yaw;
                ship.group.rotation.x += pitch;
                mouse.dx = 0; mouse.dy = 0;
            }

            // Arrow keys yaw/pitch (works without pointer lock)
            const keyYawSpeed = 1.2;
            const keyPitchSpeed = 0.8;
            const yawKeys = (keys.arrowRight ? 1 : 0) - (keys.arrowLeft ? 1 : 0);
            const pitchKeys = (keys.arrowUp ? 1 : 0) - (keys.arrowDown ? 1 : 0);
            if (yawKeys !== 0) ship.group.rotation.y += yawKeys * keyYawSpeed * dt;
            if (pitchKeys !== 0) ship.group.rotation.x += pitchKeys * keyPitchSpeed * dt;
            // Clamp pitch to avoid flipping
            ship.group.rotation.x = Math.max(-1.2, Math.min(1.2, ship.group.rotation.x));

            // Keyboard movement in ship local space
            const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(ship.group.quaternion);
            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(ship.group.quaternion);
            const right = new THREE.Vector3(0, 0, 1).applyQuaternion(ship.group.quaternion);

            const accel = new THREE.Vector3();
            if (keys.w) accel.add(forward.clone().multiplyScalar(thrustBase));
            if (keys.s) accel.add(forward.clone().multiplyScalar(-thrustBase * 0.8));
            if (keys.a) accel.add(right.clone().multiplyScalar(-strafeSpeed));
            if (keys.d) accel.add(right.clone().multiplyScalar(strafeSpeed));
            if (keys.q) ship.group.rotation.z += rollSpeed * dt;
            if (keys.e) ship.group.rotation.z -= rollSpeed * dt;
            if (keys.shift) accel.multiplyScalar(boostMultiplier);

            // Integrate velocity with some damping
            velocity.add(accel.multiplyScalar(dt));
            velocity.multiplyScalar(0.98);
            ship.group.position.add(velocity.clone().multiplyScalar(dt));

            // Make camera look ahead of the ship (chase cam)
            {
                const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(ship.group.quaternion);
                const worldShipPos = ship.group.getWorldPosition(new THREE.Vector3());
                const lookTarget = worldShipPos.clone().add(forward.clone().multiplyScalar(100));
                camera.lookAt(lookTarget);
            }

            // Update HUD
            const spd = velocity.length();
            speedValue.textContent = spd.toFixed(1);
            boostValue.textContent = keys.shift ? 'on' : 'off';

            // WebAudio engine dynamics
            if (audioCtx && engineGain && engineOsc) {
                const vol = Math.min(spd / 60, 1) * (keys.shift ? 0.24 : 0.16);
                const freq = 60 + spd * 5 + (keys.shift ? 40 : 0);
                const now = audioCtx.currentTime;
                engineGain.gain.cancelScheduledValues(now);
                engineGain.gain.linearRampToValueAtTime(vol, now + 0.05);
                engineOsc.frequency.setTargetAtTime(freq, now, 0.05);
            }

            // Fire projectiles
            fireProjectiles(dt);

            // Projectile collisions
            checkProjectileCollisions();

            // Asteroids rotation and simple collision proximity (feedback only)
            const shipPos = ship.group.position;
            for (let i = 0; i < asteroids.length; i++) {
                const a = asteroids[i];
                a.rotation.x += a.userData.rot.x * dt * 0.2;
                a.rotation.y += a.userData.rot.y * dt * 0.2;
                a.rotation.z += a.userData.rot.z * dt * 0.2;
                const d2 = a.position.distanceToSquared(shipPos);
                if (d2 < 900) { // ~30 units
                    errEl.textContent = '‚ö†Ô∏è Proximity alert: asteroid field';
                    errEl.style.display = 'block';
                }
            }

            // Animate details
            clouds.rotation.y += 0.01 * dt;
            earth.rotation.y += 0.04 * dt;
            mars.rotation.y += 0.03 * dt;
            jupiter.rotation.y += 0.02 * dt;

            // Thruster pulsate
            const t = performance.now() * 0.003;
            const pulse = 0.85 + Math.sin(t) * 0.15;
            ship.flames.forEach(f => { f.scale.set(pulse, pulse, pulse); });

            // Engine trails: spawn behind thrusters based on speed
            if (spd > 2) {
                const dir = new THREE.Vector3(1,0,0).applyQuaternion(ship.group.quaternion).normalize();
                for (let i = 0; i < ship.flames.length; i++) {
                    const worldPos = ship.flames[i].getWorldPosition(new THREE.Vector3());
                    // Spawn rate scales with speed
                    if (Math.random() < Math.min(0.2 + spd * 0.01, 0.6)) {
                        spawnTrailAt(worldPos, dir, spd);
                    }
                }
            }

            updateTrails(dt);
            updateExplosions(dt);

            if (useComposer && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
            requestAnimationFrame(animate);
        }
        animate();

        // Ensure audio starts on first interaction
        renderer.domElement.addEventListener('click', () => {
            initAudio();
        }, { once: true });
    </script>
</body>
</html>


